# -*- coding: utf-8 -*-
"""BTC-PRICE-PREDICTION-RNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14cFWBOuQYjx8SDFeqlkQNI-IMGUGTVQx
"""

## importing all of the modules that we are going to need for the project
## The modules to handle the data
import numpy as np
from google.colab import files
import io
import pandas as pd
import tensorflow as tf
import matplotlib.pyplot as plt
import math
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error

## The Keras Modules for the actual network

from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error

## Here we are uploading and preprocessing the data
## 
file = files.upload()

## Now let's build and initialize the network for Bitcoin

# read the closing prices from the historical data
dataframe_btc = pd.read_csv("BTC-USD-4.csv", usecols=[4], engine="python")

dataset_btc = dataframe_btc.values
dataset_btc = dataset_btc.astype('float32')

## Now we want to normalize dataset it's good practice for lstm NNS

scaler = MinMaxScaler(feature_range=(0,1))
dataset_btc = scaler.fit_transform(dataset_btc)      
dataset_btc = dataset_btc.reshape(dataset_btc.shape[0],1)

## Now we want to initialize the train and test set
## We want to use the first 2/3 as our training set
trainIndex = int(len(dataset_btc) * .67)

trainsetBTC = dataset_btc[0:trainIndex,:]
testsetBTC = dataset_btc[trainIndex+1:,:]

## Because the data we are looking at is sequential, we need to partition our data into
## "windows" of values in order to predict the next value
## Let's start by making a function taht works on an array to produce values for these windows

def make_window(ary, winsize=1):
  X = []
  Y = []
  i = 0
  while i < len(ary) - (1 + winsize):
    X.append(ary[i:(i+winsize),0])
    Y.append(ary[i+winsize,0])
    i += 1
  return np.array(X), np.array(Y)

lookback = 2
trainBTCX, trainBTCY = make_window(trainsetBTC, lookback)
testBTCX, testBTCY = make_window(testsetBTC, lookback)

## LSTM models require the data take a particular 3-tuple of information
## This info needs to be of the form "samples, time steps, features"

trainBTCX = np.reshape(trainBTCX, (trainBTCX.shape[0], 1,trainBTCX.shape[1]))
testBTCX = np.reshape(testBTCX, (testBTCX.shape[0],1,testBTCX.shape[1]))

## Now let's make the network
model = Sequential()
model.add(LSTM(512, input_shape=(1, lookback)))
model.add(Dense(1))
model.compile(loss='mae',optimizer="adam", metrics=["accuracy"])
history = model.fit(trainBTCX,trainBTCY,epochs=300,validation_data=(testBTCX,testBTCY),shuffle=False)

## Now we want to plot the predicted values against the actual values for the test
## portion of our data
Xt = model.predict(testBTCX)
plt.plot(scaler.inverse_transform(testBTCY.reshape(-1,1)))
plt.plot(scaler.inverse_transform(Xt))

act = []
pred = []
#for i in range(250):
i=249
Xt = model.predict(testBTCX[i].reshape(1,1,2))
print('predicted:{0}, actual:{1}'.format(scaler.inverse_transform(Xt),scaler.inverse_transform(testBTCY[i].reshape(-1,1))))
pred.append(scaler.inverse_transform(Xt))
act.append(scaler.inverse_transform(testBTCY[i].reshape(-1,1)))